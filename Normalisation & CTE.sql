## Normalisation & CTE
# 1. First Normal Form (1NF):
# a. Identify a table in the Sakila database that violates 1NF. Explain how you would normalize it to achieve 1NF.
/* First Normal Form (1NF):
Violation Example:
A table that stores multiple phone numbers in a single column violates 1NF.
In Sakila: The address table has only one phone number, so it likely follows 1NF. However, assume we had a column like phone_numbers = '123456,789101' â€” that would violate 1NF.
Normalization:
Split the column into separate rows in a new customer_phone table: */
create table customer_phone ( cust_id int, phone_no varchar (15));

# 2. Second Normal Form (2NF):
# a. Choose a table in Sakila and describe how you would determine whether it is in 2NF. 
# If it violates 2NF, explain the steps to normalize it.
/*  Second Normal Form (2NF):
Check:
Table must be in 1NF, and all non-key attributes must depend on the whole primary key.
Example Table: film_category
Composite key = (film_id, category_id)
2NF Violation:
If it had a column like category_name, it would violate 2NF since category_name depends only on category_id.
Fix:
Move category_name to a category table.

# 3. Third Normal Form (3NF):
# a. Identify a table in Sakila that violates 3NF. Describe the transitive dependencies present and outline the steps to normalize the table to 3NF.
Third Normal Form (3NF):
Check:
No transitive dependencies.
Example Table: Suppose a hypothetical film_info(film_id, title, language_id, language_name)
3NF Violation:
language_name depends on language_id, not directly on film_id.
Fix:
Remove language_name and join with language table when needed.

# 4. Normalization Process:
# a. Take a specific table in Sakila and guide through the process of normalizing it from the initial unnormalized form up to at least 2NF.
4. Normalization Process (Unnormalized to 2NF):
Unnormalized table:
film_details(film_id, title, actor, language)

Step 1: 1NF:
Split actors and languages into separate rows (one actor/language per row).
Step 2: 2NF:
Create separate film_actor and film_language tables to eliminate partial dependencies.*/

# 5. CTE Basics:
# a. Write a query using a CTE to retrieve the distinct list of actor names and the number of films they have acted in from the actor and film_actor tables.
with actor_films as(
	select actor_id, count(film_id) as film_count from film_actor
    group by actor_id )
select a.first_name, a.last_name, af.film_count from actor a 
join actor_films af on a.actor_id = af.actor_id;

# 6. CTE with Joins:
# a. Create a CTE that combines information from the film and language tables to display the film title, language name, and rental rate.
with film_language as(
	select f.title, f.rental_rate, l.name as language_name from film f
    join language l on f.language_id = l.language_id)
select * from film_language;

# 7. CTE for Aggregation:
# a. Write a query using a CTE to find the total revenue generated by each customer (sum of payments) from the customer and payment tables.
with customer_revenue as(
	select customer_id, sum(amount) as total_revenue from payment
    group by customer_id)
select * from customer_revenue;

# 8. CTE with Window Functions:
# a. Utilize a CTE with a window function to rank films based on their rental duration from the film table.
with film_rank as(
	select title, rental_duration,
    Rank() over (order by rental_duration desc) as Rank_num from film )
select * from film_rank;

# 9. CTE and Filtering:
# a. Create a CTE to list customers who have made more than two rentals, and then join this CTE with the customer table to retrieve additional customer details.
with frequent_customers as(
    select customer_id, COUNT(*) as rental_count from rental
    group by customer_id
    HAVING COUNT(*) > 2
)
select c.* from customer c
join frequent_customers fc on c.customer_id = fc.customer_id;

# 10. CTE for Date Calculations:
# a. Write a query using a CTE to find the total number of rentals made each month, considering the rental_date from the rental table.
with monthly_rentals as(
    select DATE_FORMAT(rental_date, '%Y-%m') as rental_month, COUNT(*) AS total_rentals from rental
    GROUP BY rental_month)
SELECT * FROM monthly_rentals;

# 11. CTE and Self-Join:
# a. Create a CTE to generate a report showing pairs of actors who have appeared in the same film together, using the film_actor table.
with actor_pairs as (
    select fa1.film_id, fa1.actor_id as actor1, fa2.actor_id as actor2 from film_actor fa1
    join film_actor fa2 on fa1.film_id = fa2.film_id
    where fa1.actor_id < fa2.actor_id)
SELECT * FROM actor_pairs;

# 12. CTE for Recursive Search:
# a. Implement a recursive CTE to find all employees in the staff table who report to a specific manager, considering the reports_to column
CREATE TABLE employee (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(100),
    reports_to INT
);

INSERT INTO employee VALUES 
(1, 'CEO', NULL),
(2, 'Manager A', 1),
(3, 'Manager B', 1),
(4, 'Staff A1', 2),
(5, 'Staff A2', 2),
(6, 'Staff B1', 3);
WITH RECURSIVE employee_hierarchy AS (
    SELECT emp_id, emp_name, reports_to
    FROM employee
    WHERE reports_to IS NULL

    UNION ALL

    SELECT e.emp_id, e.emp_name, e.reports_to
    FROM employee e
    JOIN employee_hierarchy eh ON e.reports_to = eh.emp_id)

SELECT * FROM employee_hierarchy;